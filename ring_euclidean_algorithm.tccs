%% TCCs associated with theory ring_euclidean_algorithm
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_algorithm_TCCS: THEORY BEGIN

	% Assuming TCC generated (at line 33, column 14) for
	% euclidean_domain[T, +, *, zero, one]
	% generated from assumption euclidean_domain.fullset_is_ring_with_one
	  % unfinished
	IMP_euclidean_domain_TCC1: OBLIGATION
	ring_with_one?[T, +, *, zero, one](fullset[T])
	
	% Subtype TCC generated (at line 48, column 17) for  b
	% expected type  (difference(R, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    difference[T](R, singleton[T](zero))(b)
	
	% Subtype TCC generated (at line 48, column 49) for  a
	% expected type  (difference(R, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC2: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero IMPLIES difference[T](R, singleton[T](zero))(a)
	
	% Subtype TCC generated (at line 48, column 13) for  z`2
	% expected type  (difference(d1`1, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC3: OBLIGATION
	FORALL (d1:
	            [R: (euclidean_domain?[T, +, *, zero, one]),
	             phi:
	               {phi: [(difference(R, singleton(zero))) -> nat] |
	                  euclidean_pair?(R, phi)},
	             {f_phi: [(R), (remove(zero, R)) -> [(R), (R)]] |
	                euclidean_f_phi?(R, phi)(f_phi)}],
	          z: [(d1`1), (remove(zero, d1`1))]):
	    difference[T](d1`1, singleton[T](zero))(z`2)
	
	% Subtype TCC generated (at line 48, column 45) for  z`1
	% expected type  (difference(d1`1, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC4: OBLIGATION
	FORALL (d1:
	            [R: (euclidean_domain?[T, +, *, zero, one]),
	             phi:
	               {phi: [(difference(R, singleton(zero))) -> nat] |
	                  euclidean_pair?(R, phi)},
	             {f_phi: [(R), (remove(zero, R)) -> [(R), (R)]] |
	                euclidean_f_phi?(R, phi)(f_phi)}],
	          z: [(d1`1), (remove(zero, d1`1))]):
	    NOT z`1 = zero IMPLIES difference[T](d1`1, singleton[T](zero))(z`1)
	
	% Subtype TCC generated (at line 48, column 17) for  b
	% expected type  (difference(R, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC5: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]), b: (remove(zero, R))):
	    difference[T](R, singleton[T](zero))(b)
	
	% Subtype TCC generated (at line 48, column 49) for  a
	% expected type  (difference(R, singleton(zero)))
	  % proved
	euclidean_gcd_algorithm_TCC6: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]), a: (R)):
	    NOT a = zero IMPLIES difference[T](R, singleton[T](zero))(a)
	
	% Subtype TCC generated (at line 44, column 50) for  b
	% expected type  (R)
	  % proved
	euclidean_gcd_algorithm_TCC7: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)): rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES R(b)
	
	% Subtype TCC generated (at line 44, column 52) for  rem
	% expected type  (remove(zero, R))
	  % proved
	euclidean_gcd_algorithm_TCC8: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)):
	       rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES remove[T](zero, R)(rem)
	
	% Termination TCC generated (at line 44, column 13) for
	% euclidean_gcd_algorithm(R, phi, f_phi)(b, rem)
	  % proved
	euclidean_gcd_algorithm_TCC9: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND phi(a) >= phi(b) IMPLIES
	     FORALL (rem: (R)):
	       rem = (f_phi(a, b))`2 AND NOT rem = zero IMPLIES
	        lex2(phi(rem), IF b = zero THEN 0 ELSE phi(b) ENDIF) <
	         lex2(phi(b), IF a = zero THEN 0 ELSE phi(a) ENDIF)
	
	% Subtype TCC generated (at line 46, column 45) for  b
	% expected type  (R)
	  % proved
	euclidean_gcd_algorithm_TCC10: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES R(b)
	
	% Subtype TCC generated (at line 46, column 47) for  a
	% expected type  (remove(zero, R))
	  % proved
	euclidean_gcd_algorithm_TCC11: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES remove[T](zero, R)(a)
	
	% Termination TCC generated (at line 46, column 8) for
	% euclidean_gcd_algorithm(R, phi, f_phi)(b, a)
	  % proved
	euclidean_gcd_algorithm_TCC12: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT a = zero AND NOT phi(a) >= phi(b) IMPLIES
	     lex2(phi(a), IF b = zero THEN 0 ELSE phi(b) ENDIF) <
	      lex2(phi(b), IF a = zero THEN 0 ELSE phi(a) ENDIF)
	
	% The subtype TCC (at line 48, column 13) in decl nil for
	% term generated from euclidean_gcd_algorithm  z`2
	% expected type  (difference(d1`1, singleton(zero)))
	% The subtype TCC (at line 48, column 45) in decl nil for
	% term generated from euclidean_gcd_algorithm  z`1
	% expected type  (difference(d1`1, singleton(zero)))
	% The subtype TCC (at line 48, column 17) in decl nil for
	% term generated from euclidean_gcd_algorithm  b
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 48, column 49) in decl nil for
	% term generated from euclidean_gcd_algorithm  a
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 41, column 13) in decl nil for
	% term generated from euclidean_gcd_algorithm  a
	% expected type  (difference(R, singleton(zero)))
	% The subtype TCC (at line 41, column 23) in decl nil for
	% term generated from euclidean_gcd_algorithm  b
	% expected type  (difference(R, singleton(zero)))
	% Subtype TCC generated (at line 56, column 19) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % proved
	Euclid_theorem_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R)), g: (remove[T](zero, R))):
	    NOT empty?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})) AND
	     subset?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b}), R)
	
	% The subtype TCC (at line 48, column 13) in decl nil for
	 % term generated from euclidean_gcd_algorithm  z`2
	    % expected type  (difference(d1`1, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC3
	% The subtype TCC (at line 48, column 45) in decl nil for
	 % term generated from euclidean_gcd_algorithm  z`1
	    % expected type  (difference(d1`1, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC4
	% The subtype TCC (at line 48, column 17) in decl nil for
	 % term generated from euclidean_gcd_algorithm  b
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC5
	% The subtype TCC (at line 48, column 49) in decl nil for
	 % term generated from euclidean_gcd_algorithm  a
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC6
	% The subtype TCC (at line 41, column 13) in decl nil for
	 % term generated from euclidean_gcd_algorithm  a
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC6
	% The subtype TCC (at line 41, column 23) in decl nil for
	 % term generated from euclidean_gcd_algorithm  b
	    % expected type  (difference(R, singleton(zero)))
	  % is subsumed by euclidean_gcd_algorithm_TCC5
	
	% Subtype TCC generated (at line 57, column 19) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = (f_phi(a, b))`2 OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % untried
	Euclid_theorem_TCC2: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R)), g: (remove[T](zero, R))):
	    NOT empty?[T]
	            (extend[T, (R), bool, FALSE]
	                 ({x: (R) | x = (f_phi(a, b))`2 OR x = b}))
	     AND
	     subset?[T]
	         (extend[T, (R), bool, FALSE]({x: (R) | x = (f_phi(a, b))`2 OR x = b}),
	          R)
	
	% Subtype TCC generated (at line 65, column 14) for
	% extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})
	% expected type  {X | NOT empty?(X) AND subset?(X, R)}
	  % unfinished
	euclidean_gcd_alg_correctness_TCC1: OBLIGATION
	FORALL (R: (euclidean_domain?[T, +, *, zero, one]),
	          (phi: [(difference(R, singleton(zero))) -> nat]
	               | euclidean_pair?[T, +, *, zero](R, phi)),
	          (f_phi: [[(R), (remove(zero, R))] -> [(R), (R)]]
	               | euclidean_f_phi?[T, +, *, zero](R, phi)(f_phi)),
	          a: (R), b: (remove[T](zero, R))):
	    NOT empty?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b})) AND
	     subset?[T](extend[T, (R), bool, FALSE]({x: (R) | x = a OR x = b}), R)

END ring_euclidean_algorithm_TCCS

%% TCCs associated with theory ring_euclidean_gcd_algorithm_Z
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_gcd_algorithm_Z_TCCS: THEORY BEGIN

	% Subtype TCC generated (at line 87, column 40) for  fullset[int]
	% expected type  (euclidean_domain?
	%      [int,
	%       restrict
	%           [[numfield, numfield], [int, int], numfield]
	%           (+),
	%       restrict
	%           [[numfield, numfield], [int, int], numfield]
	%           (*),
	%       0, 1])
	  % untried
	Z_TCC1: OBLIGATION
	euclidean_domain?
	      [int, restrict[[numfield, numfield], [int, int], numfield](+),
	       restrict[[numfield, numfield], [int, int], numfield](*), 0, 1]
	      (fullset[int])
	
	% Subtype TCC generated (at line 92, column 24) for  j
	% expected type  posnat
	  % untried
	f_phi_Z_TCC1: OBLIGATION
	FORALL ((j: int | j /= 0)): j > 0 IMPLIES j >= 0
	
	% Subtype TCC generated (at line 92, column 40) for  -j
	% expected type  posnat
	  % untried
	f_phi_Z_TCC2: OBLIGATION
	FORALL ((j: int | j /= 0)): NOT j > 0 IMPLIES -j >= 0 AND -j > 0
	
	% Subtype TCC generated (at line 96, column 67) for  f_phi_Z
	% expected type  [[(Z), (remove(0, Z))] -> [(Z), (Z)]]
	  % untried
	phi_Z_and_f_phi_Z_ok_TCC1: OBLIGATION
	((FORALL (x: int): Z(x)) AND
	    FORALL (x: int): x /= 0 IFF remove[int](0, Z)(x))
	   AND
	   FORALL (x1: [int, {j: int | j /= 0}]): Z(f_phi_Z(x1)`2) AND Z(f_phi_Z(x1)`1)
	
	% Subtype TCC generated (at line 96, column 60) for  phi_Z
	% expected type  {phi: [(difference(Z, singleton(0))) -> nat] |
	%    euclidean_pair?(Z, phi)}
	  % untried
	phi_Z_and_f_phi_Z_ok_TCC2: OBLIGATION
	(FORALL (x: int): x /= 0 IFF difference[int](Z, singleton[int](0))(x)) AND
	   euclidean_pair?
	       [int, restrict[[numfield, numfield], [int, int], numfield](+),
	        restrict[[numfield, numfield], [int, int], numfield](*), 0]
	       (Z, phi_Z)
	
	% Subtype TCC generated (at line 102, column 23) for
	% extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j})
	% expected type  {X | NOT empty?(X) AND subset?(X, Z)}
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC1: OBLIGATION
	FORALL (i: int, (j: int | j /= 0)):
	    NOT empty?[int](extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j}))
	     AND
	     subset?[int](extend[int, (Z), bool, FALSE]({x: (Z) | x = i OR x = j}), Z)
	
	% Subtype TCC generated (at line 102, column 106) for  i
	% expected type  (Z)
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC2: OBLIGATION
	FORALL (i: int, (j: int | j /= 0)): Z(i)
	
	% Subtype TCC generated (at line 102, column 108) for  j
	% expected type  (remove(0, Z))
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC3: OBLIGATION
	FORALL ((j: int | j /= 0)): remove[int](0, Z)(j)
	
	% Subtype TCC generated (at line 102, column 97) for  f_phi_Z
	% expected type  {f_phi: [(Z), (remove(0, Z)) -> [(Z), (Z)]] |
	%    euclidean_f_phi?(Z, phi_Z)(f_phi)}
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC4: OBLIGATION
	FORALL ((j: int | j /= 0)):
	    (((FORALL (x: int): Z(x)) AND
	       FORALL (x: int): x /= 0 IFF remove[int](0, Z)(x))
	      AND
	      FORALL (x1: [int, {j: int | j /= 0}]):
	        Z(f_phi_Z(x1)`2) AND Z(f_phi_Z(x1)`1))
	     AND
	     euclidean_f_phi?
	         [int, restrict[[numfield, numfield], [int, int], numfield](+),
	          restrict[[numfield, numfield], [int, int], numfield](*), 0]
	         (Z, phi_Z)(f_phi_Z)
	
	% Assuming TCC generated (at line 102, column 51) for
	% euclidean_gcd_algorithm
	%     [int, restrict[[numfield, numfield], [int, int], numfield](+),
	%      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1]
	% generated from assumption ring_euclidean_algorithm.fullset_is_ring
	  % untried
	euclidean_gcd_alg_correctness_in_Z_TCC5: OBLIGATION
	FORALL ((j: int | j /= 0)):
	    ring?[int, restrict[[numfield, numfield], [int, int], numfield](+),
	          restrict[[numfield, numfield], [int, int], numfield](*), 0]
	        (fullset[int])

END ring_euclidean_gcd_algorithm_Z_TCCS

%% TCCs associated with theory ring_euclidean_gcd_algorithm_Zi
%% This file was automatically generated by PVS, please **do not modify** by hand.
ring_euclidean_gcd_algorithm_Zi_TCCS: THEORY BEGIN
%-- No TCC was generated for theory ring_euclidean_gcd_algorithm_Zi
END ring_euclidean_gcd_algorithm_Zi_TCCS
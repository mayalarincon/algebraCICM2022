("ring_nz_closed_def" ring_nz_closed_def nz_closed?_TCC1 0 (nz_closed?_TCC1-1 nil 3294093042 ("" (skosimp) (("" (typepred "x1!1`1") (("" (postpone) nil nil)) nil)) nil) nil shostak))("ring_homomorphisms_def" ring_homomorphisms_def IMP_ring_TCC1 0 (IMP_ring_TCC1-1 nil 3716286944 ("" (lemma "R1_is_ring") (("" (propax) nil nil)) nil) ((R1_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_ring_TCC2 0 (IMP_ring_TCC2-1 nil 3716286944 ("" (lemma "R2_is_ring") (("" (propax) nil nil)) nil) ((R2_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_homomorphisms_TCC1 0 (IMP_homomorphisms_TCC1-1 nil 3716286944 ("" (lemma "R1_is_ring") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (assert) nil nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def "algebra/") (abelian_group? const-decl "bool" group_def "algebra/") (R1_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def IMP_homomorphisms_TCC2 0 (IMP_homomorphisms_TCC2-1 nil 3716286944 ("" (lemma "R2_is_ring") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (assert) nil nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def "algebra/") (abelian_group? const-decl "bool" group_def "algebra/") (R2_is_ring formula-decl nil ring_homomorphisms_def nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homomorphism?_TCC1 0 (R_homomorphism?_TCC1-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (flatten) (("" (hide-all-but (-1 1)) (("" (expand "abelian_group?") (("" (expand "group?") (("" (expand "monoid?") (("" (expand "monad?") (("" (flatten) (("" (hide-all-but (-1 1)) (("" (expand "star_closed?") (("" (inst -1 "a!1" "b!1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (monoid? const-decl "bool" monoid_def "algebra/") (star_closed? const-decl "bool" groupoid_def "algebra/") (member const-decl "bool" sets nil) (monad? const-decl "bool" monad_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homomorphism?_TCC2 0 (R_homomorphism?_TCC2-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (expand "star_closed?") (("" (inst -1 "a!1" "b!1") (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (star_closed? const-decl "bool" groupoid_def "algebra/") (member const-decl "bool" sets nil)) nil))("ring_homomorphisms_def" ring_homomorphisms_def R_homo_is_homo 0 (R_homo_is_homo-1 nil 3709409057 ("" (skosimp) (("" (typepred "x!1") (("" (expand "R_homomorphism?") (("" (expand "homomorphism?") (("" (skosimp) (("" (inst -1 "a!1" "b!1") (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (homomorphism? const-decl "bool" homomorphisms "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def zero_to_zero_TCC1 0 (zero_to_zero_TCC1-1 nil 3715688144 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (expand "monoid?") (("" (expand "monad?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (monoid? const-decl "bool" monoid_def "algebra/") (member const-decl "bool" sets nil) (monad? const-decl "bool" monad_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def zero_to_zero 0 (zero_to_zero-1 nil 3715688344 ("" (skosimp) (("" (lemma "homo_one") (("" (inst -1 "R1!1" "R2!1" "phi!1") (("" (lemma "R_homo_is_homo") (("" (inst -1 "R1!1" "R2!1" "phi!1") nil nil)) nil)) nil)) nil)) nil) ((zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (homo_one formula-decl nil homomorphisms "algebra/") (R_homo_is_homo judgement-tcc nil ring_homomorphisms_def nil) (R1!1 skolem-const-decl "ring[T1, s1, p1, zero1]" ring_homomorphisms_def nil) (R2!1 skolem-const-decl "ring[T2, s2, p2, zero2]" ring_homomorphisms_def nil) (phi!1 skolem-const-decl "R_homomorphism(R1!1, R2!1)" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (homomorphism type-eq-decl nil homomorphisms "algebra/") (homomorphism? const-decl "bool" homomorphisms "algebra/") (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (group nonempty-type-eq-decl nil group "algebra/") (group? const-decl "bool" group_def "algebra/") (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("ring_homomorphisms_def" ring_homomorphisms_def inv1_to_inv2_homo_TCC1 0 (inv1_to_inv2_homo_TCC1-1 nil 3709409057 ("" (skosimp) (("" (typepred "R1!1") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (flatten) (("" (hide-all-but (-2 1)) (("" (typepred "x!1") (("" (expand "inv_exists?") (("" (inst -2 "x!1") (("" (skosimp) (("" (hide -3) (("" (typepred "inv(x!1)") (("" (hide -2) (("" (replace -1 -3 rl) (("" (hide -1) (("" (rewrite "cancel_left_plus") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring nonempty-type-eq-decl nil ring "algebra/") (ring? const-decl "bool" ring_def "algebra/") (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (abelian_group? const-decl "bool" group_def "algebra/") (cancel_left_plus formula-decl nil ring "algebra/") (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (inv const-decl "{y | x * y = one AND y * x = one}" group "algebra/") (inv_exists? const-decl "bool" group_def "algebra/") (group? const-decl "bool" group_def "algebra/")) nil))("ring_homomorphisms_def" ring_homomorphisms_def inv1_to_inv2_homo 0 (inv1_to_inv2_homo-1 nil 3709410310 ("" (skosimp) (("" (skosimp) (("" (typepred "phi!1") (("" (expand "R_homomorphism?") (("" (inst -1 "x!1" "inv(x!1)") (("" (flatten) (("" (hide -2) (("" (assert) (("" (rewrite "zero_to_zero") (("" (lemma "plus_zero[T2,s2,p2,zero2]") (("" (inst -1 "inv(phi!1(x!1))") (("" (replace -2 -1) (("" (hide -2) (("" (rewrite "plus_associative" -1 :dir rl) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inv_right formula-decl nil group "algebra/") (plus_zero formula-decl nil ring "algebra/") (left_identity formula-decl nil monad "algebra/") (inv_left formula-decl nil group "algebra/") (plus_associative formula-decl nil ring "algebra/") (zero_to_zero formula-decl nil ring_homomorphisms_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (inv const-decl "{y | x * y = one AND y * x = one}" group "algebra/") (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T1 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (set type-eq-decl nil sets nil) (s1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (p1 formal-const-decl "[T1, T1 -> T1]" ring_homomorphisms_def nil) (zero1 formal-const-decl "T1" ring_homomorphisms_def nil) (ring? const-decl "bool" ring_def "algebra/") (ring nonempty-type-eq-decl nil ring "algebra/") (T2 formal-nonempty-type-decl nil ring_homomorphisms_def nil) (s2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (p2 formal-const-decl "[T2, T2 -> T2]" ring_homomorphisms_def nil) (zero2 formal-const-decl "T2" ring_homomorphisms_def nil) (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)) shostak))("division_ring_def" division_ring_def division_ring?_TCC1 0 (division_ring?_TCC1-1 nil 3293998727 ("" (skosimp*) (("" (typepred "x1!1`1") (("" (typepred "x1!1`2") (("" (postpone) nil nil)) nil)) nil)) nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC2 0 (division_ring?_TCC2-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("division_ring_def" division_ring_def division_ring?_TCC3 0 (division_ring?_TCC3-1 nil 3293998727 ("" (postpone) nil nil) nil shostak))("finite_integral_domain" finite_integral_domain nzx_member_S_TCC1 0 (nzx_member_S_TCC1-1 nil 3711982167 ("" (skosimp) (("" (typepred "S!1") (("" (expand "finite_integral_domain?") (("" (assert) nil nil)) nil)) nil)) nil) ((finite_integral_domain? const-decl "bool" finite_integral_domain nil) (set type-eq-decl nil sets nil) (T formal-nonempty-type-decl nil finite_integral_domain nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil))("ring_with_one_homomorphism" ring_with_one_homomorphism ring_w_one_isomorphic_groupoid 0 (ring_w_one_isomorphic_groupoid-1 nil 3853327936 ("" (skosimp) (("" (lemma "bijective_inverse_exists[(R!1),(S!1)]") (("" (skosimp) (("" (case "bijective?[(R!1), (S!1)](phi!1)") (("1" (inst -2 "phi!1") (("1" (expand "exists1") (("1" (flatten) (("1" (skosimp) (("1" (inst 1 "x!1(zero2)" "x!1(one2)") (("1" (expand "ring_with_one?") (("1" (postpone) nil nil)) nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil) nil shostak))("ring_general_results" ring_general_results_extras teste 0 (teste-1 nil 3813595903 ("" (skeep) (("" (postpone) nil nil)) nil) nil shostak))("ring_principal_ideal" ring_principal_ideal convergent_chain 0 (convergent_chain-1 nil 3853575777 ("" (skosimp*) (("" (lemma "ideal_iunion_ideal") (("" (inst -1 "R!1" "seq!1") (("" (split) (("1" (typepred "R!1") (("1" (expand "principal_ideal_ring?") (("1" (flatten) (("1" (inst -2 "IUnion(seq!1)") (("1" (assert) (("1" (skeep) (("1" (lemma "gen_is_member") (("1" (inst -1 "R!1" "a") (("1" (expand "member") (("1" (replace -3 -1 rl) (("1" (expand "IUnion" -1) (("1" (skeep) (("1" (inst 1 "i") (("1" (skeep) (("1" (typepred "k") (("1" (decompose-equality 1) (("1" (iff) (("1" (prop) (("1" (lemma "principal_ideal_subset") (("1" (inst -1 "R!1" "a" "seq!1(i)") (("1" (assert) (("1" (case "subset?(seq!1(k), IUnion(seq!1))") (("1" (expand "subset?" -1) (("1" (inst -1 "x!1") (("1" (expand "member") (("1" (replace -7 -2 rl) (("1" (expand "subset?" -2) (("1" (inst -2 "x!1") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "subset?") (("2" (skeep) (("2" (expand "member") (("2" (hide-all-but (-1 1)) (("2" (expand "IUnion") (("2" (inst 1 "k") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -7 "i") nil nil)) nil)) nil) ("2" (inst -8 "i" "k") (("2" (assert) (("2" (expand "subset?") (("2" (inst -8 "x!1") (("2" (expand "member") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((zero formal-const-decl "T" ring_principal_ideal nil) (* formal-const-decl "[T, T -> T]" ring_principal_ideal nil) (+ formal-const-decl "[T, T -> T]" ring_principal_ideal nil) (T formal-nonempty-type-decl nil ring_principal_ideal nil) (ideal_iunion_ideal formula-decl nil ring_ideal nil) (IUnion const-decl "set[T]" indexed_sets nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) nil nil nil (ideal? const-decl "bool" ring_ideal_def nil) (ideal type-eq-decl nil ring_ideal_def nil) (subset? const-decl "bool" sets nil) (principal_ideal_subset formula-decl nil ring_principal_ideal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (gen_is_member formula-decl nil ring_principal_ideal nil) (NOT const-decl "[bool -> bool]" booleans nil) (sequence type-eq-decl nil sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (principal_ideal_ring type-eq-decl nil ring_principal_ideal_def nil) (principal_ideal_ring? const-decl "bool" ring_principal_ideal_def nil) (ring nonempty-type-eq-decl nil ring nil) (ring? const-decl "bool" ring_def nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_TCC1 0 (power_TCC1-1 nil 3292925562 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans) (bool nonempty-type-eq-decl nil booleans) (NOT const-decl "[bool -> bool]" booleans) (number nonempty-type-decl nil numbers) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (>= const-decl "bool" reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (nat nonempty-type-eq-decl nil naturalnumbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_TCC2 0 (power_TCC2-1 nil 3292925568 ("" (grind) nil nil) nil shostak))("cyclic_monoid_def" cyclic_monoid_def power_0 0 (power_0-1 nil 3292925609 ("" (grind) nil nil) ((power def-decl "T" groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_1 0 (power_1-1 nil 3292925615 ("" (grind) nil nil) ((power def-decl "T" groups) (one formal-const-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (T formal-nonempty-type-decl nil groups) (right_identity formula-decl nil monoids)) shostak))("cyclic_monoid_def" cyclic_monoid_def one_power 0 (one_power-1 nil 3292925621 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "power" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ((* formal-const-decl "[T, T -> T]" groups) (left_identity formula-decl nil monoids) (nat_induction formula-decl nil naturalnumbers) (one formal-const-decl "T" groups) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_def 0 (power_def-1 nil 3292925779 ("" (induct "n") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (inst - "a!1") (("2" (expand "power" 1) (("2" (lemma "cancel_left" ("z" "a!1" "x" "power(a!1, j!1 + 1)" "y" "power(a!1, j!1) * a!1")) (("2" (rewrite "associative") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((associative formula-decl nil monoids) (cancel_left formula-decl nil groups) (one formal-const-decl "T" groups) (right_identity formula-decl nil monoids) (left_identity formula-decl nil monoids) (nat_induction formula-decl nil naturalnumbers) (* formal-const-decl "[T, T -> T]" groups) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_mult 0 (power_mult-1 nil 3292925654 ("" (induct "m") (("1" (skolem!) (("1" (rewrite "power_0") (("1" (assert) nil nil)) nil)) nil) ("2" (skosimp*) (("2" (inst - "a!1" "n!1+1") (("2" (rewrite "power_def" -1) (("2" (expand "power" 1 2) (("2" (rewrite "associative" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((power_def formula-decl nil groups) (associative formula-decl nil monoids) (one formal-const-decl "T" groups) (right_identity formula-decl nil monoids) (power_0 formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_power 0 (power_power-1 nil 3292926190 ("" (induct "m") (("1" (skolem!) (("1" (rewrite "power_0") (("1" (rewrite "power_0") nil nil)) nil)) nil) ("2" (skosimp*) (("2" (expand "power" 1 1) (("2" (inst - "a!1" "n!1") (("2" (replace -1) (("2" (rewrite "power_mult") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((power_mult formula-decl nil groups) (power_0 formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (* const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power def-decl "T" groups) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_commutes 0 (power_commutes-1 nil 3292926297 ("" (skolem!) (("" (rewrite "power_mult") (("" (rewrite "power_mult") nil nil)) nil)) nil) ((power_mult formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def inv_power 0 (inv_power-1 nil 3292926316 ("" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "power" 1 1) (("2" (rewrite "inv_star") (("2" (rewrite "power_def") (("2" (inst - "a!1") (("2" (lemma "cancel_right" ("z" "inv(a!1)" "x" "inv(power(a!1, j!1))" "y" "power(inv(a!1), j!1)")) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((inv_star formula-decl nil groups) (cancel_right formula-decl nil groups) (+ const-decl "[numfield, numfield -> numfield]" number_fields) (- const-decl "[numfield, numfield -> numfield]" number_fields) (numfield nonempty-type-eq-decl nil number_fields) (power_def formula-decl nil groups) (inv_one formula-decl nil groups) (nat_induction formula-decl nil naturalnumbers) (power def-decl "T" groups) (inv const-decl "{y | x * y = one AND y * x = one}" groups) (one formal-const-decl "T" groups) (* formal-const-decl "[T, T -> T]" groups) (AND const-decl "[bool, bool -> bool]" booleans) (= const-decl "[T, T -> boolean]" equalities) (T formal-nonempty-type-decl nil groups) (pred type-eq-decl nil defined_types) (nat nonempty-type-eq-decl nil naturalnumbers) (>= const-decl "bool" reals) (bool nonempty-type-eq-decl nil booleans) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (boolean nonempty-type-decl nil booleans) (number nonempty-type-decl nil numbers)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_inv_right 0 (power_inv_right-1 nil 3292926510 ("" (skolem!) (("" (rewrite "inv_power" :dir rl) (("" (assert) nil nil)) nil)) nil) ((inv_power formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers) (inv_right formula-decl nil groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def power_inv_left 0 (power_inv_left-1 nil 3292926554 ("" (skolem!) (("" (rewrite "inv_power" :dir rl) (("" (assert) nil nil)) nil)) nil) ((inv_power formula-decl nil groups) (T formal-nonempty-type-decl nil groups) (number nonempty-type-decl nil numbers) (boolean nonempty-type-decl nil booleans) (number_field_pred const-decl "[number -> boolean]" number_fields) (number_field nonempty-type-from-decl nil number_fields) (real_pred const-decl "[number_field -> boolean]" reals) (real nonempty-type-from-decl nil reals) (rational_pred const-decl "[real -> boolean]" rationals) (rational nonempty-type-from-decl nil rationals) (integer_pred const-decl "[rational -> boolean]" integers) (int nonempty-type-eq-decl nil integers) (bool nonempty-type-eq-decl nil booleans) (>= const-decl "bool" reals) (nat nonempty-type-eq-decl nil naturalnumbers) (inv_left formula-decl nil groups)) shostak))("cyclic_monoid_def" cyclic_monoid_def cyclic_group_is_abelian 0 (cyclic_group_is_abelian-1 nil 3293272131 ("" (skolem 1 ("G!1")) (("" (typepred "G!1") (("" (expand "cyclic_group?") (("" (flatten) (("" (expand "abelian_group?") (("" (assert) (("" (expand "cyclic?") (("" (skolem!) (("" (replace -1 -2) (("" (expand "commutative_over?") (("" (skosimp*) (("" (replace -1) (("" (assert) (("" (expand "generated_by") (("" (skosimp*) (("" (lemma "expt_mult" ("a" "a!1" "i" "i!1" "j" "i!2")) (("" (lemma "expt_mult" ("a" "a!1" "i" "i!2" "j" "i!1")) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cyclic_group nonempty-type-eq-decl nil groups) (cyclic_group? const-decl "bool" groups) (set type-eq-decl nil sets) (T formal-nonempty-type-decl nil groups) (NOT const-decl "[bool -> bool]" booleans) (bool nonempty-type-eq-decl nil booleans) (boolean nonempty-type-decl nil booleans) (commutative_over? const-decl "bool" operator_defs_more) (generated_by const-decl "group" groups) (int nonempty-type-eq-decl nil integers) (integer_pred const-decl "[rational -> boolean]" integers) (rational nonempty-type-from-decl nil rationals) (rational_pred const-decl "[real -> boolean]" rationals) (real nonempty-type-from-decl nil reals) (real_pred const-decl "[number_field -> boolean]" reals) (number_field nonempty-type-from-decl nil number_fields) (number_field_pred const-decl "[number -> boolean]" number_fields) (number nonempty-type-decl nil numbers) (expt_mult formula-decl nil groups) (member const-decl "bool" sets) (cyclic? const-decl "bool" groups) (abelian_group? const-decl "bool" groups_def)) shostak))("groups_scaf" groups_scaf IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3861917862 ("" (lemma "fullset_is_group") (("" (propax) nil nil)) nil) ((fullset_is_group formula-decl nil groups_scaf nil)) nil (IMP_finite_groups assuming "finite_groups[groups_scaf.T, groups_scaf.*, groups_scaf.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("products_subgroups" products_subgroups IMP_normal_subgroups_TCC1 0 (IMP_normal_subgroups_TCC1-1 nil 3529777527 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil products_subgroups nil)) nil (IMP_normal_subgroups assuming "algebra@normal_subgroups[products_subgroups.T, products_subgroups.*, products_subgroups.one].normal_subgroups" "fullset_is_group: ASSUMPTION group_def[normal_subgroups.T, normal_subgroups.*, normal_subgroups.one].group?(sets[normal_subgroups.T].fullset)")))("group_action" group_action IMP_lagrange_index_TCC1 0 (IMP_lagrange_index_TCC1-1 nil 3799510538 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil group_action nil)) nil (IMP_lagrange_index assuming "lagrange_index[group_action.T, group_action.*, group_action.one].lagrange_index" "fullset_is_group: ASSUMPTION group_def[lagrange_index.T, lagrange_index.*, lagrange_index.one].group?(sets[lagrange_index.T].fullset)")))("normalizer_centralizer" normalizer_centralizer IMP_group_action_TCC1 0 (IMP_group_action_TCC1-1 nil 3799515121 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil normalizer_centralizer nil)) nil (IMP_group_action assuming "group_action[normalizer_centralizer.T, normalizer_centralizer.*, normalizer_centralizer.one, normalizer_centralizer.T].group_action" "fullset_is_group: ASSUMPTION group_def[group_action.T, group_action.*, group_action.one].group?(sets[group_action.T].fullset)")))("cauchy" cauchy IMP_finite_cyclic_groups_TCC1 0 (IMP_finite_cyclic_groups_TCC1-1 nil 3531317209 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil cauchy nil)) nil (IMP_finite_cyclic_groups assuming "finite_cyclic_groups[cauchy.T, cauchy.*, cauchy.one].finite_cyclic_groups" "fullset_is_group: ASSUMPTION group_def[finite_cyclic_groups.T, finite_cyclic_groups.*, finite_cyclic_groups.one].group?(sets[finite_cyclic_groups.T].fullset)")))("p_groups" p_groups IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3530721851 ("" (rewrite "fullset_is_group") nil nil) ((fullset_is_group formula-decl nil p_groups nil)) nil (IMP_finite_groups assuming "finite_groups[p_groups.T, p_groups.*, p_groups.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("sylow_theorems" sylow_theorems IMP_finite_groups_TCC1 0 (IMP_finite_groups_TCC1-1 nil 3807089562 ("" (rewrite "T_is_group") nil nil) ((T_is_group formula-decl nil sylow_theorems nil)) nil (IMP_finite_groups assuming "finite_groups[sylow_theorems.T, sylow_theorems.*, sylow_theorems.one].finite_groups" "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))("ring_ideal" ring_ideal IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3846255750 ("" (lemma "fullset_is_ring") (("" (propax) nil nil)) nil) ((fullset_is_ring formula-decl nil ring_ideal nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_ideal.T, ring_ideal.+, ring_ideal.*, ring_ideal.zero].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("quotient_rings" quotient_rings IMP_ring_cosets_lemmas_TCC1 0 (IMP_ring_cosets_lemmas_TCC1-1 nil 3793737437 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil quotient_rings nil)) nil (IMP_ring_cosets_lemmas assuming "ring_cosets_lemmas[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring_cosets_lemmas" "fullset_is_ring: ASSUMPTION ring_def[ring_cosets_lemmas.T, ring_cosets_lemmas.+, ring_cosets_lemmas.*, ring_cosets_lemmas.zero].ring?(sets[ring_cosets_lemmas.T].fullset)")))("ring_homomorphism_lemmas" ring_homomorphism_lemmas IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3852714674 ("" (lemma "R1_is_ring") (("" (propax) nil nil)) nil) ((R1_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_homomorphism_lemmas" ring_homomorphism_lemmas IMP_ring_basic_properties_TCC2 0 (IMP_ring_basic_properties_TCC2-1 nil 3852714674 ("" (lemma "R2_is_ring") (("" (propax) nil nil)) nil) ((R2_is_ring formula-decl nil ring_homomorphism_lemmas nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_center" ring_center IMP_ring_basic_properties_TCC1 0 (IMP_ring_basic_properties_TCC1-1 nil 3808759749 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_center nil)) nil (IMP_ring_basic_properties assuming "ring_basic_properties[ring_center.T, ring_center.+, ring_center.*, ring_center.zero].ring_basic_properties" "fullset_is_ring: ASSUMPTION ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?(sets[ring_basic_properties.T].fullset)")))("ring_unit" ring_unit IMP_ring_ideal_TCC1 0 (IMP_ring_ideal_TCC1-1 nil 3861799364 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_unit nil)) nil (IMP_ring_ideal assuming "ring_ideal[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero].ring_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_ideal.T, ring_ideal.+, ring_ideal.*, ring_ideal.zero].ring?(sets[ring_ideal.T].fullset)")))("ring_unit" ring_unit IMP_ring_with_one_TCC1 0 (IMP_ring_with_one_TCC1-1 nil 3861799364 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_unit nil)) nil (IMP_ring_with_one assuming "ring_with_one[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero, ring_unit.one].ring_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))("division_ring_extras" division_ring_extras IMP_ring_unit_TCC1 0 (IMP_ring_unit_TCC1-1 nil 3801236149 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil division_ring_extras nil)) nil (IMP_ring_unit assuming "ring_unit[division_ring_extras.T, division_ring_extras.+, division_ring_extras.*, division_ring_extras.zero, division_ring_extras.one].ring_unit" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_unit.T, ring_unit.+, ring_unit.*, ring_unit.zero, ring_unit.one].ring_with_one?(sets[ring_unit.T].fullset)")))("ring_zn" ring_zn IMP_quotient_rings_with_one_TCC1 0 (IMP_quotient_rings_with_one_TCC1-1 nil 3813420475 ("" (expand "ring_with_one?") (("" (expand "ring?") (("" (split) (("1" (expand "abelian_group?") (("1" (expand "group?") (("1" (expand "monoid?") (("1" (split) (("1" (expand "monad?") (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "inv_exists?") (("3" (skosimp) (("3" (inst 1 "-x!1") (("1" (assert) nil nil) ("2" (expand "fullset") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "left_distributive?") (("4" (skosimp) (("4" (expand "restrict") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (expand "right_distributive?") (("5" (skosimp) (("5" (expand "restrict") (("5" (propax) nil nil)) nil)) nil)) nil) ("6" (expand "monoid?") (("6" (expand "monad?") (("6" (split) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ring? const-decl "bool" ring_def nil) (right_distributive? const-decl "bool" operator_defs_more nil) (left_distributive? const-decl "bool" operator_defs_more nil) (int_times_int_is_int application-judgement "int" integers nil) (abelian_group? const-decl "bool" group_def nil) (monoid? const-decl "bool" monoid_def nil) (commutative? const-decl "bool" operator_defs nil) (inv_exists? const-decl "bool" group_def nil) (minus_int_is_int application-judgement "int" integers nil) (x!1 skolem-const-decl "(fullset[int])" ring_zn nil) (- const-decl "[numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (associative? const-decl "bool" operator_defs nil) (monad? const-decl "bool" monad_def nil) (restrict const-decl "R" restrict nil) (identity? const-decl "bool" operator_defs nil) (fullset const-decl "set" sets nil) (member const-decl "bool" sets nil) (star_closed? const-decl "bool" groupoid_def nil) (int_plus_int_is_int application-judgement "int" integers nil) (group? const-decl "bool" group_def nil) (ring_with_one? const-decl "bool" ring_with_one_def nil)) nil (IMP_quotient_rings_with_one assuming "quotient_rings_with_one[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].quotient_rings_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one?(sets[quotient_rings_with_one.T].fullset)")))("product_finseq_sets_ring" product_finseq_sets_ring IMP_cartesian_product_quot_ring_TCC1 0 (IMP_cartesian_product_quot_ring_TCC1-1 nil 3796724087 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil product_finseq_sets_ring nil)) nil (IMP_cartesian_product_quot_ring assuming "cartesian_product_quot_ring[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero].cartesian_product_quot_ring" "fullset_is_ring: ASSUMPTION ring_def[cartesian_product_quot_ring.T, cartesian_product_quot_ring.+, cartesian_product_quot_ring.*, cartesian_product_quot_ring.zero].ring?(sets[cartesian_product_quot_ring.T].fullset)")))("product_finseq_sets_ring" product_finseq_sets_ring IMP_ring_with_one_TCC1 0 (IMP_ring_with_one_TCC1-1 nil 3796724381 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil product_finseq_sets_ring nil)) nil (IMP_ring_with_one assuming "ring_with_one[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero, product_finseq_sets_ring.one].ring_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one.T, ring_with_one.+, ring_with_one.*, ring_with_one.zero, ring_with_one.one].ring_with_one?(sets[ring_with_one.T].fullset)")))("chinese_remainder_theorem_rings" chinese_remainder_theorem_rings IMP_product_finseq_sets_ring_TCC1 0 (IMP_product_finseq_sets_ring_TCC2-1 nil 3793737450 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil chinese_remainder_theorem_rings nil)) nil (IMP_product_finseq_sets_ring assuming "product_finseq_sets_ring[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, chinese_remainder_theorem_rings.one].product_finseq_sets_ring" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[product_finseq_sets_ring.T, product_finseq_sets_ring.+, product_finseq_sets_ring.*, product_finseq_sets_ring.zero, product_finseq_sets_ring.one].ring_with_one?(sets[product_finseq_sets_ring.T].fullset)")))("chinese_remainder_theorem_Z" chinese_remainder_theorem_Z IMP_chinese_remainder_theorem_rings_TCC1 0 (IMP_chinese_remainder_theorem_rings_TCC1-1 nil 3861799385 ("" (lemma "Z_commutative_ring_w_one") (("" (expand "commutative_ring_with_one?") (("" (flatten) (("" (hide -2) (("" (expand "Z") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((commutative_ring_with_one? const-decl "bool" ring_with_one_def nil) (Z const-decl "ring[int, restrict[[numfield, numfield], [int, int], numfield](+),
     restrict[[numfield, numfield], [int, int], numfield](*), 0]" ring_zn nil) (Z_commutative_ring_w_one formula-decl nil ring_zn nil)) nil (IMP_chinese_remainder_theorem_rings assuming "chinese_remainder_theorem_rings[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].chinese_remainder_theorem_rings" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[chinese_remainder_theorem_rings.T, chinese_remainder_theorem_rings.+, chinese_remainder_theorem_rings.*, chinese_remainder_theorem_rings.zero, chinese_remainder_theorem_rings.one].ring_with_one?(sets[chinese_remainder_theorem_rings.T].fullset)")))("finite_integral_domain" finite_integral_domain IMP_integral_domain_TCC1 0 (IMP_integral_domain_TCC1-1 nil 3793817342 ("" (rewrite "fullset_is_integral_domain") nil nil) ((fullset_is_integral_domain formula-decl nil finite_integral_domain nil)) nil))("finite_integral_domain" finite_integral_domain IMP_ring_nz_closed_TCC1 0 (IMP_ring_nz_closed_TCC1-1 nil 3793817342 ("" (lemma "fullset_is_integral_domain") (("" (expand "integral_domain?") (("" (expand "commutative_ring?") (("" (expand "ring_nz_closed?") (("" (prop) nil nil)) nil)) nil)) nil)) nil) ((integral_domain? const-decl "bool" integral_domain_def "algebra/") (ring_nz_closed? const-decl "bool" ring_nz_closed_def "algebra/") (commutative_ring? const-decl "bool" ring_def "algebra/") (fullset_is_integral_domain formula-decl nil finite_integral_domain nil)) nil))("finite_integral_domain" finite_integral_domain IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3793817342 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil finite_integral_domain nil)) nil))("ring_divides" ring_divides IMP_ring_with_id_one_generator_TCC1 0 (IMP_ring_with_id_one_generator_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_ring_with_id_one_generator assuming "ring_with_id_one_generator[ring_divides.T, ring_divides.+, ring_divides.*, ring_divides.zero, ring_divides.one].ring_with_id_one_generator" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_id_one_generator.T, ring_with_id_one_generator.+, ring_with_id_one_generator.*, ring_with_id_one_generator.zero, ring_with_id_one_generator.one].ring_with_one?(sets[ring_with_id_one_generator.T].fullset)")))("ring_divides" ring_divides IMP_ring_nz_closed_aux_TCC1 0 (IMP_ring_nz_closed_aux_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_ring_nz_closed_aux assuming "ring_nz_closed_aux[ring_divides.T, ring_divides.+, ring_divides.*, ring_divides.zero].ring_nz_closed_aux" "fullset_is_ring: ASSUMPTION ring_def[ring_nz_closed_aux.T, ring_nz_closed_aux.+, ring_nz_closed_aux.*, ring_nz_closed_aux.zero].ring?(sets[ring_nz_closed_aux.T].fullset)")))("ring_divides" ring_divides IMP_op_finseq_TCC1 0 (IMP_op_finseq_TCC1-1 nil 3840203950 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (expand "ring?") (("" (expand "abelian_group?") (("" (expand "group?") (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (abelian_group? const-decl "bool" group_def nil) (group? const-decl "bool" group_def nil) (ring? const-decl "bool" ring_def nil) (fullset_is_ring_with_one formula-decl nil ring_divides nil)) nil (IMP_op_finseq assuming "op_finseq[ring_divides.T, ring_divides.*, ring_divides.one].op_finseq" "fullset_is_monoid: ASSUMPTION monoid_def[op_finseq.T, op_finseq.*, op_finseq.one].monoid?(sets[op_finseq.T].fullset)")))("ring_prime_ideal" ring_prime_ideal IMP_ring_one_generator_TCC1 0 (IMP_ring_one_generator_TCC1-1 nil 3793905401 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_prime_ideal nil)) nil (IMP_ring_one_generator assuming "ring_one_generator[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring_one_generator" "fullset_is_ring: ASSUMPTION ring_def[ring_one_generator.T, ring_one_generator.+, ring_one_generator.*, ring_one_generator.zero].ring?(sets[ring_one_generator.T].fullset)")))("ring_with_one_prime_ideal" ring_with_one_prime_ideal IMP_ring_prime_ideal_TCC1 0 (IMP_ring_prime_ideal_TCC1-1 nil 3856964765 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_with_one_prime_ideal nil)) nil (IMP_ring_prime_ideal assuming "ring_prime_ideal[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero].ring_prime_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring?(sets[ring_prime_ideal.T].fullset)")))("ring_with_one_prime_ideal" ring_with_one_prime_ideal IMP_quotient_rings_with_one_TCC1 0 (IMP_quotient_rings_with_one_TCC1-1 nil 3856964765 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_with_one_prime_ideal nil)) nil (IMP_quotient_rings_with_one assuming "quotient_rings_with_one[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero, ring_with_one_prime_ideal.one].quotient_rings_with_one" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one?(sets[quotient_rings_with_one.T].fullset)")))("ring_maximal_ideal" ring_maximal_ideal IMP_ring_prime_ideal_TCC1 0 (IMP_ring_prime_ideal_TCC1-1 nil 3793987454 ("" (rewrite "fullset_is_ring") nil nil) ((fullset_is_ring formula-decl nil ring_maximal_ideal nil)) nil (IMP_ring_prime_ideal assuming "ring_prime_ideal[ring_maximal_ideal.T, ring_maximal_ideal.+, ring_maximal_ideal.*, ring_maximal_ideal.zero].ring_prime_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_prime_ideal.T, ring_prime_ideal.+, ring_prime_ideal.*, ring_prime_ideal.zero].ring?(sets[ring_prime_ideal.T].fullset)")))("ring_with_one_maximal_ideal" ring_with_one_maximal_ideal IMP_ring_with_one_prime_ideal_TCC1 0 (IMP_ring_with_one_prime_ideal_TCC1-1 nil 3861799401 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_with_one_maximal_ideal nil)) nil (IMP_ring_with_one_prime_ideal assuming "ring_with_one_prime_ideal[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero, ring_with_one_maximal_ideal.one].ring_with_one_prime_ideal" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_prime_ideal.T, ring_with_one_prime_ideal.+, ring_with_one_prime_ideal.*, ring_with_one_prime_ideal.zero, ring_with_one_prime_ideal.one].ring_with_one?(sets[ring_with_one_prime_ideal.T].fullset)")))("ring_with_one_maximal_ideal" ring_with_one_maximal_ideal IMP_ring_maximal_ideal_TCC1 0 (IMP_ring_maximal_ideal_TCC1-1 nil 3861799401 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_with_one_maximal_ideal nil)) nil (IMP_ring_maximal_ideal assuming "ring_maximal_ideal[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero].ring_maximal_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_maximal_ideal.T, ring_maximal_ideal.+, ring_maximal_ideal.*, ring_maximal_ideal.zero].ring?(sets[ring_maximal_ideal.T].fullset)")))("ring_general_results" ring_general_results IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3798279991 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_general_results nil)) nil (IMP_ring_with_one_basic_properties assuming "ring_with_one_basic_properties[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero, ring_general_results.one].ring_with_one_basic_properties" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_basic_properties.T, ring_with_one_basic_properties.+, ring_with_one_basic_properties.*, ring_with_one_basic_properties.zero, ring_with_one_basic_properties.one].ring_with_one?(sets[ring_with_one_basic_properties.T].fullset)")))("ring_general_results" ring_general_results IMP_ring_characteristic_def_TCC1 0 (IMP_ring_characteristic_def_TCC1-1 nil 3798279991 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) (nil (fullset_is_ring_with_one formula-decl nil ring_general_results nil)) nil (IMP_ring_characteristic_def assuming "ring_characteristic_def[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero].ring_characteristic_def" "fullset_is_ring: ASSUMPTION ring_def[ring_characteristic_def.T, ring_characteristic_def.+, ring_characteristic_def.*, ring_characteristic_def.zero].ring?(sets[ring_characteristic_def.T].fullset)")))("ring_principal_ideal_domain" ring_principal_ideal_domain IMP_ring_with_one_maximal_ideal_TCC1 0 (IMP_ring_with_one_maximal_ideal_TCC1-1 nil 3856627874 ("" (rewrite "fullset_is_ring_with_one") nil nil) ((fullset_is_ring_with_one formula-decl nil ring_principal_ideal_domain nil)) nil (IMP_ring_with_one_maximal_ideal assuming "ring_with_one_maximal_ideal[ring_principal_ideal_domain.T, ring_principal_ideal_domain.+, ring_principal_ideal_domain.*, ring_principal_ideal_domain.zero, ring_principal_ideal_domain.one].ring_with_one_maximal_ideal" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_maximal_ideal.T, ring_with_one_maximal_ideal.+, ring_with_one_maximal_ideal.*, ring_with_one_maximal_ideal.zero, ring_with_one_maximal_ideal.one].ring_with_one?(sets[ring_with_one_maximal_ideal.T].fullset)")))("ring_principal_ideal_domain" ring_principal_ideal_domain IMP_ring_principal_ideal_TCC1 0 (IMP_ring_principal_ideal_TCC1-1 nil 3856627874 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil ring_principal_ideal_domain nil)) nil (IMP_ring_principal_ideal assuming "ring_principal_ideal[ring_principal_ideal_domain.T, ring_principal_ideal_domain.+, ring_principal_ideal_domain.*, ring_principal_ideal_domain.zero].ring_principal_ideal" "fullset_is_ring: ASSUMPTION ring_def[ring_principal_ideal.T, ring_principal_ideal.+, ring_principal_ideal.*, ring_principal_ideal.zero].ring?(sets[ring_principal_ideal.T].fullset)")))("euclidean_domain" euclidean_domain IMP_ring_with_one_basic_properties_TCC1 0 (IMP_ring_with_one_basic_properties_TCC1-1 nil 3855928571 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil euclidean_domain nil)) nil (IMP_ring_with_one_basic_properties assuming "ring_with_one_basic_properties[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero, euclidean_domain.one].ring_with_one_basic_properties" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_basic_properties.T, ring_with_one_basic_properties.+, ring_with_one_basic_properties.*, ring_with_one_basic_properties.zero, ring_with_one_basic_properties.one].ring_with_one?(sets[ring_with_one_basic_properties.T].fullset)")))("euclidean_domain" euclidean_domain IMP_euclidean_ring_TCC1 0 (IMP_euclidean_ring_TCC1-1 nil 3858611879 ("" (lemma "fullset_is_ring_with_one") (("" (expand "ring_with_one?") (("" (flatten) nil nil)) nil)) nil) ((ring_with_one? const-decl "bool" ring_with_one_def nil) (fullset_is_ring_with_one formula-decl nil euclidean_domain nil)) nil (IMP_euclidean_ring assuming "euclidean_ring[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero].euclidean_ring" "fullset_is_ring: ASSUMPTION ring_def[euclidean_ring.T, euclidean_ring.+, euclidean_ring.*, euclidean_ring.zero].ring?(sets[euclidean_ring.T].fullset)")))("ring_euclidean_algorithm" ring_euclidean_algorithm IMP_euclidean_domain_TCC1 0 (IMP_euclidean_domain_TCC1-1 nil 3859538045 ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil) ((fullset_is_ring_with_one formula-decl nil ring_euclidean_algorithm nil)) nil (IMP_euclidean_domain assuming "euclidean_domain[ring_euclidean_algorithm.T, ring_euclidean_algorithm.+, ring_euclidean_algorithm.*, ring_euclidean_algorithm.zero, ring_euclidean_algorithm.one].euclidean_domain" "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[euclidean_domain.T, euclidean_domain.+, euclidean_domain.*, euclidean_domain.zero, euclidean_domain.one].ring_with_one?(sets[euclidean_domain.T].fullset)")))